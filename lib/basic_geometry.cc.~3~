#include "../include/basic_types.h"
#include "../include/basic_geometry.h"

using namespace std;

PixelColor PointT::ToPixelColor(const PointT &p){
  double x=p.GetX(), y=p.GetY(), z=p.GetZ();
  x=min(x, 1.0), x=max(x, 0.0);  
  y=min(y, 1.0), y=max(y, 0.0);  
  z=min(z, 1.0), z=max(z, 0.0);  
  return PixelColor( static_cast<BYTE>(x*256), static_cast<BYTE>(y*256), static_cast<BYTE>(z*256) );
}

PointT Cross(const PointT &a, const PointT &b){
  return PointT( a.y_ * b.z_ - a.z_ * b.y_, a.z_ * b.x_ - a.x_ * b.z_, a.x_ * b.y_ - a.y_ * b.x_ );
}

double Intersect(const SphereT &sphere, const RayT &ray, PointT &ip){
  return sphere.Intersect(ray, ip);
}  

double Intersect(const PlaneT &pl, const RayT &ray, PointT &ip){
  return pl.Intersect(ray, ip);
}

double PlaneT::Intersect(const RayT &ray, PointT &ip)const{

}

double SphereT::Intersect(const RayT &ray, PointT &ip)const{

}

PointT PlaneT::GetSurfaceNormal(const PointT &surface_point)const{
  return o_;
}

PointT SphereT::GetSurfaceNormal(const PointT &surface_point)const{
  return (surface_point - center_).Unit();
}

int RayT::FindFirstHitInVec(const vector<Renderer*> &objs)const{
  double hit_dis=1e30;
  int hit_ret=-1;
  int i=0;
  for(const auto &obj: objs){
    PointT ip;
    double x=obj->Intersect(*this, ip);
    if (Sign(x)>=0)
      if (x<hit_dis){
        hit_dis=x;
        hit_ret=i;
      }
    i++;
  }
  return hit_ret;
}
