#ifndef BASIC_GEOMETRY_H
#define BASIC_GEOMETRY_H

#include <cmath>

typedef double CoordinateT;

template<class T>
T Sqr(const T &a){
  return a*a;
}

class PointT{

 public:
  PointT(){}

  PointT(CoordinateT x, CoordinateT y, CoordinateT z)
    :x_(x), y_(y), z_(z){
  }

  CoordinateT GetX()const{ return x_; }
  CoordinateT GetY()const{ return y_; }
  CoordinateT GetZ()const{ return z_; }
  
  CoordinateT Length2()const{ return Sqr(x_)+Sqr(y_)+Sqr(z_); }
  CoordinateT Length()const{ return sqrt(Length2()); }
  PointT Unit()const{ CoordinateT d=Length(); return PointT(x_/d, y_/d, z_/d); }
  PointT operator+(const PointT &b)const{ return PointT(x_+b.x_, y_+b.y_, z_+b.z_); }
  PointT operator-(const PointT &b)const{ return PointT(x_-b.x_, y_-b.y_, z_-b.z_); }
  PointT operator*(const CoordinateT &k)const{ return PointT(k*x_, k*y_, k*z_); }
  CoordinateT operator*(const PointT &b)const{ return x_*b.x_ + y_*b.y_ + z_*b.z_; }//dot product
  friend PointT Cross(const PointT &a, const PointT &b)const;

 private:
  CoordinateT x_, y_, z_;

};

PointT Cross(const PointT &a, const PointT &b)const{
  return PointT( a.y_ * b.z_ - a.z_ * b.y_, a.z_ * b.x_ - a.x_ * b.z_, a.x_ * b.y_ - a.y_ * b.x_ );
}

class RayT{
  
 public:
  RayT(){}

  RayT(PointT O, PointT R)
    :O_(O), R_(R){
    R_=R_.Unit();
  }

  PointT GetO()const{ return O_; }
  PointT GetR()const{ return R_; }

 private:
  PointT O_, R_;

};


class Renderer{

 public:
  virtual bool Intersect(const RayT &r, PointT &ip)const;

  Renderer(){}

  Renderer(double a, double b)
    :reflect_coefficient(a), refract_coefficient(b){
  }

 private:
  double reflect_coefficient, refract_coefficient;

};

class PlaneT: public Renderer{
  
 public:
  PlaneT(){}
  
  PlaneT(PointT O, PointT R)
    :O_(O), R_(R){
    R_=R_.Unit();
  }

  PointT GetO()const{ return O_; }
  PointT GetR()const{ return R_; }

  bool Intersect(const RayT &r, PointT &ip)const;

 private:
  PointT O_, R_; //R_ is unit vector

};

bool Intersect(const PlaneT &pl, const RayT &r, PointT &ip){
  return pl.Intersect(r, ip);
}

class SphereT: Renderer{
  
 public:
  SphereT(){}

 SphereT(double a, double b, PointT O, CoordinateT R)
    :O_(O), R_(R){
  }

  PointT GetO()const{ return O_; }
  CoordinateT GetR()const{ return R_; }

  bool Intersect(const RayT &r, PointT &ip)const;

 private:
  PointT O_;
  CoordinateT R_;
  
};

bool Intersect(const SphereT &s, const RayT &r, Point &ip){
  return s.Intersect(r, ip);
}  

#endif
